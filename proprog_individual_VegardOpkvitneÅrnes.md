# Individual Professional Programming Assignment
Because the reflection on the code will be relevant for the presentation of my groups bachelor project, all code present in this reflection paper will be from the bachelor project.
## Good Code
### Example One: Map Rendering
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/b26b6c9c500a6510d5c8d5bc46f010f9b2c53cf2/core/src/main/kotlin/ktxGamePrototype01/screen/OpenWorldScreen.kt#L242-L311  
I would describe the map rendering system within the game engine as good, not just because it executes its task well but because of the future extensions that could
be put upon it. The rendering reads a two-dimensional array from file  (e.g. open world map: https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/main/assets/maps/mapOpenWorld01.txt)
which describes what graphic should be in each grid section of the map through different symbols. Through this, separate components can also be given to separate entities
in the world map, giving them distinct features. The map is compatible with any size, and is therefore used both for the mini games and the open world. Adding new types of elements
to the map is a simple process: place an unused symbol in the map file where you want it to manifest in the game, then add its graphic to the "assets/graphic" folder and fetch it within
the code (as seen on lines 243-252), thereafter in the when-condition, add the new symbol condition that should set the graphic. If the new map element should contain a new component/system,
add an if-condition that adds the specific component to the entity when the symbol that corresponds to the element is read. Alternatively if the new element should contain an existing
system, but with modified specific behaviour, the variables within the relevant component should be given information indicating its type on entity creation, and the new functionality
in the system should be added inside an if-condition and only used if that condition is met. An example of this is how both a wall and an enemy might have collision, but enemies deal damage
on collision, and walls just prevent player from moving further.
While this function completely fulfills it's job, it is an inherently pragmatic solution as it is re-declared in every screen (i.e. every separate game type), with each asset variable
being redeclared in each of the functions. For performance optimisation, increasing readability of code, and ease of scaling up the map rendering functionality, the function should have
ideally been a part of its own class/system, but instead we developed it knowing the limitations the map would have, intentionally not making it overly engineered compared to the effort we knew
we would put into it. It is worth mentioning that it can easily be further developed because as the map reader only requires a grid style text file to render a map, it should be feasible to develop a functionality allowing teachers to design the style of the rooms the quizzes from their classrooms should take place in, or alternatively easy for developers to make multiple default ones they can pick from. By connecting the maps to the database, they can also be shareable between teachers.

### Example Two: Quiz Entity Rendering
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/b26b6c9c500a6510d5c8d5bc46f010f9b2c53cf2/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/QuizSystem.kt#L93-L184  
The purpose of the function is to create entities on the map which corresponds to an answer to a question, it renders the question text in a set position at the center top of the screen, and the answer text above the corresponding answer entities. When the user walks up to an answer and presses the "Activate"-button, the current question is answered and the old question and answers are destroyed while the new ones are created by the same function. I consider it good because it is a rapid way of allowing the quiz data to be acquired from the database and into the game when direct connection between game engine and database could not be achieved (as the Android SDK was no longer accessible) instead of passing this potentially great amount of data through the parameter. Quiz data is stored in files fetched frequently when in the application view, and contains lines in the format of "[Question number]-[Question text/Answer Text]-[Bool if its question]-[Bool for true/false answer]-[points gained for answering question]", e.g. "1Question one-true-true-10". Each new line after that is an answer until it reaches new start number which indicated the beginning of a new question. When player answers a question, the quiz entity rendering continues drawing the question and answers for the next question, once it reaches the next question it stops the line reading loop, saves the index it is at, and resumes rendering the next question and answer at stored index once quiz has been answered. If there are no more questions, the completed condition is set to true which provides a result screen, plays a sound, and updates the player score. As stated this is the workaround for accessing data from database in the game, and can work for any type of curricula, on any type of device (like iPhones or Windows Desktop) as long as the file with the format exists, thus expanding the service for more devices wont require changing logic in game engine. A negative, shortsighted side of the solution is that what separates the data within the datafile is the "-" symbol, which in turn means that if teacher uses the symbol in either question or answers, it will break the logic of the system and quiz will be unplayable as data is separated incorrectly.

## Bad Code
### Example One: Collision Preventing Player From Moving Further
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/f0d532d87fb3cec2d87ab90b76b096c28febad6b/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/InteractableSystem.kt#L155-L162  
This is a case where pragmatism came at the cost of quality of game. The collision system with walls works by moving the player a short distance back in the direction they came from when colliding with the wall. There are multiple issues with this. First and foremost is the fact that if movement of the player is fast enough, they can clip through walls, this can partially be solved by placing a cap on movement speed on the joystick movement functionality, since at the moment the player can move faster the further they drag their finger away from the point they first clicked. Regardless of fixing the clipping issue, the fact remains that it looks ugly. When colliding with a wall the collision should ideally make player stand still or potentially slide along it if walking in a diagonal path, the sliding part works partially, but since the collision works by pushing the player back, the collision looks shaky as player collides and moves a few pixel back in rapid succession. Another bad side is the use of a magic number, in this case "0.69". The number was used because it was roughly the shortest distance player could be pushed back when colliding, if the push was lower the collision would simply stop working and players would be able to pass through completely freely. Attempts were made at improving the collision system, but as the functionality required to make it more natural was located in multiple entity-systems, the logic was less intuitive than expected, so no alternative solution worked better than this. It essentially became a question of whether or not it was worth spending time on perfecting what was already mostly functional, and we concluded that it was better to move on as the issues were mostly aesthetically, and if a user intentionally decided to brute force their way through a wall there would not be any systematic consequences of the action.

### Example Two: Fetching All User Data On Login
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/f0d532d87fb3cec2d87ab90b76b096c28febad6b/android/src/main/kotlin/ktxGamePrototype01/DBObject.kt#L22-L42  
Due to issues with creating asynchronous functions, this functionality was added to make frequent data access easy, the code is not inherently bad on its own, however it is bad in the context that it is used. Upon login in, every field stored in the users database document is saved locally in the "userObject" variable, the object is accessible from any fragment whether it is to fetch new database data using variables in the object, or to write information in the object to the fragment. There are two noticable issues with this, first and foremost if the information did not get fetched by the time the user clicks the menu and opens a new fragment it can lead to incomplete data being shown, or more likely the system crashing, this issue is especially present when logging out of one account and into a new one. The other issue which persists, is that some of the data stored in the "userObject" variable either remains in the object or in the devices cache when logging out from one user and into another. This issue especially affects the open world game, as even though all local quiz files are deleted and new ones are fetched, the open world game sometimes still decides to show the data which was shown for the previous user logged in even though it shouldn't. So either the variable responsible for fetching all the quizzes for each classrooms are not updated properly or LibGDX has a cache that we didn't figure out how to wipe.  

## Code Refactoring

### Interactable System Refactoring
#### Before Refactoring:  
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/b26b6c9c500a6510d5c8d5bc46f010f9b2c53cf2/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/InteractableSystem.kt#L52-L153

#### After Refactoring:  
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/8f5e73ffadb5dc81bebb85d884ba0cf6e05134ab/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/InteractableSystem.kt#L52-L161

#### Description of Refactoring
The purpose of the refactoring was to greatly simplify the system used to handle different types of interaction. Interaction can be anything from different types of collision to different ways of activating elements in the world, essentially any function with purpose to affect of be affected by the surrounding world is placed within this system. The solution is simple yet very effective at increasing readability, modularity, and performance: Use enumerator(s) instead of booleans to signify types, replace if-conditions with a when-condition (switch), and place the logic that was present within the if-statements inside their own function instead. The procedure does however require multiple files to be changed to a lesser extent, more than what is seen within the files above, these files can be found in the sub-chapter underneath named <em>Additional Links to Changes Related to Previous Refactoring</em>. An enum describing interactable type was created and stored as a variable within the InteractableComponent, at the moment there are 5 different types: CORRECTANSWER, WRONGANSWER, TEACHER, QUEST, and DEFAULT, if we were to add new types of interactables the name of the type would need to be added to this enumerator declaration. Then when an entity is created with an interactable component, the type can be specified as any of the aforementioned ones or eventual new ones created. The processEntity function in the InteractableSystem will constantly loop and update all entities with the interactable component, and while updating it checks the InteractableType contained within the entity and launches the specific function related to updating that type of interactable entity.
The positive sides to modularity and readability is visible from the links provided above, the content within the collision checker was reduced from 40 lines to 13, and made it far clearer what happens when the specific condition is met. In addition, the content of the all if-conditions became clutter preventing readability, so moving it all into a function made it easier to find the specifics one is looking for. Adding new types of interaction is now just a matter of adding one for the condition in the when(), and a function containing the logic to be launched. The improved performance might not be noticeable at this scale, but definitely exists as instead of checkering through multiple if-conditions to determine what to do, it simply jumps straight to the relevant when-condition, which means that the performance gain of using a when expression over if-condition grows depending on the amount of Interactable types present.
This should have been done from the very start, but as it was initially only made as a way for walls to prevent the player from moving further, we simply continued extending it in the fastest way possible for the quickest results without thinking much about modifying existing logic for increased modularity, we did however get increasingly aware of the issue and its valuable to see how a simple solution can increase the quality of the code so tremendously.




#### Additional Links to Changes Related to Previous Refactoring:
Enum in InteractableComponent:  
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/8f5e73ffadb5dc81bebb85d884ba0cf6e05134ab/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/components/InteractableComponent.kt#L7-L22  
Setting Quest entity's interactable type to InteractableType.QUEST  
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/8f5e73ffadb5dc81bebb85d884ba0cf6e05134ab/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/QuizQuestSystem.kt#L69  
Setting Teacher entity's interactable type to InteractableType.TEACHER  
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/8f5e73ffadb5dc81bebb85d884ba0cf6e05134ab/core/src/main/kotlin/ktxGamePrototype01/screen/OpenWorldScreen.kt#L195  
Setting Quiz Answer entity's interactable type to InteractableType.CORRECTANSWER or InteractableType.WRONGANSWER based on whether the answer is correct.  
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/8f5e73ffadb5dc81bebb85d884ba0cf6e05134ab/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/QuizSystem.kt#L164-L165  

## Professionalism in Programming Reflection.
Personally i value professionalism in programming greatly, though i can at times be a bit reluctant to following proper standards out of laziness and tunnel vision when wanting to make a functionality work. This can be seen in the aforementioned code examples, as well as other sides of the bachelor project in particular with how easy it is to become overly pragmatic in the approach. Professionalism in Programming affects every aspect of a developers experience when programming, and as people tend to take inspiration from other peoples code in open source repositories, it should be common courtesy to develop with the same level of professionalism you expect to see from other peoples code, even in personal projects. In short, the golden rule applies to programming as well. We realised this while developing as it became apparent through Github's traffic statistics that several individual IDs (at least 30, only shows for last 2 weeks) had cloned our repository during development of bachelor task. An example of a necessary professionalism is documentation, both i terms of documents and comments as it is the initial guide to logic. During the project we struggled with bad documentation of libraries simply because we developed everything in Kotlin, and documentation for Kotlin libraries primarily showed its examples in Java (E.G. Firestore and LibGDX/LibKTX). Its hypocritical for me to complain about lack of documentation though as our code lacks any publicly available documents for people who found the repository, although we did inculde it to a degree in the bachelor thesis appendix. I did however comment code to a moderate degree, believing that short precise comments will be less ambiguous than an abundance of them. We were also consciously trying to follow programming paradigms when developing, attempting to follow an object-oriented pattern because we are most familiar with it, however as the game engine is built upon an entity-component-system, it became increasingly apparent that it is inherently more data-oriented. In short, this is because each entity is really just a set of data with continuously running functions updating said data, and increases performance by becoming more cache-friendly. If we were more aware of the principles of data-oriented design before developing the ECS, the standards could have been followed to a greater extent. Programming paradigms are truly important as it provides preemptive expectations from readers (e.g. co-workers) when reading code, and i experienced it first hand when attempting to understand systems which were data-oriented without much understanding of the logic that entails.
Professionalism has become increasingly important to me and in looking back at previous programs developed its awkward thinking about how carefree i have been at times in solving problems. What the primary thing i have realised throughout the project and profesional programming course is the need for refactoring code as its difficult to see how to optimally and professionally write code during development, while it generally turns into an easy and valuable task in the after initial completion.