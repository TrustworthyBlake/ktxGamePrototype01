# Individual Professional Programming Assignment
Because the reflection on the code will be relevant for the presentation of my groups bachelor project, all code present in this reflection paper will be from the bachelor project.
## Good Code
### Example One: Map Rendering
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/b26b6c9c500a6510d5c8d5bc46f010f9b2c53cf2/core/src/main/kotlin/ktxGamePrototype01/screen/OpenWorldScreen.kt#L242-L311  
I would describe the map rendering system within the game engine as good, not just because it executes its task well but because of the future extensions that could
be put upon it. The rendering reads a two-dimensional array from file  (e.g. open world map: https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/main/assets/maps/mapOpenWorld01.txt)
which describes what graphic should be in each grid section of the map through different symbols. Through this, separate components can also be given to separate entities
in the world map, giving them distinct features. The map is compatible with any size, and is therefore used both for the mini games and the open world. Adding new types of elements
to the map is a simple process: place an unused symbol in the map file where you want it to manifest in the game, then add its graphic to the "assets/graphic" folder and fetch it within
the code (as seen on lines 243-252), thereafter in the when-condition, add the new symbol condition that should set the graphic. If the new map element should contain a new component/system,
add an if-condition that adds the specific component to the entity when the symbol that corresponds to the element is read. Alternatively if the new element should contain an existing
system, but with modified specific behaviour, the variables within the relevant component should be given information indicating its type on entity creation, and the new functionality
in the system should be added inside an if-condition and only used if that condition is met. An example of this is how both a wall and an enemy might have collision, but enemies deal damage
on collision, and walls just prevent player from moving further.
While this function completely fulfills it's job, it is an inherently pragmatic solution as it is re-declared in every screen (i.e. every separate game type), with each asset variable
being redeclared in each of the functions. For performance optimisation, increasing readability of code, and ease of scaling up the map rendering functionality, the function should have
ideally been a part of its own class/system, but instead developed it knowing the limitations the map would have, intentionally not making it overly engineered compared to the effort we knew
we would put into it. It is worth mentioning that it can easily be further developed because as the map reader only requires a grid style text file to render a map, it should be feasible to develop a functionality allowing teachers to design the style of the rooms the quizzes from their classrooms should take place in, or alternatively easy for developers to make multiple default ones they can pick from. By connecting the maps to the database, they can also be shareable between teachers.

### Example Two: Quiz Entity Rendering
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/b26b6c9c500a6510d5c8d5bc46f010f9b2c53cf2/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/QuizSystem.kt#L93-L184  
The purpose of the function is to create entities on the map which corresponds to an answer to a question, it renders the question text in a set position at the center top of the screen, and the answer text above the corresponding answer entities. When the user walks up to an answer and presses the "Activate"-button, the current question is answered and the old question and answers are destroyed while the new ones are created by the same function. I consider it good because it is a rapid way of allowing the quiz data to be acquired from the database and into the game when direct connection between game engine and database could not be achieved (as the Android SDK was no longer accessible) instead of passing this potentially great amount of data through the parameter. Quiz data is stored in files fetched frequently when in the application view, and contains lines in the format of "[Question number]-[Question text/Answer Text]-[Bool if its question]-[Bool for true/false answer]-[points gained for answering question]", e.g. "1Question one-true-true-10". Each new line after that is an answer until it reaches new start number which indicated the beginning of a new question. When player answers a question, the quiz entity rendering continues drawing the question and answers for the next question, once it reaches the next question it stops the line reading loop, saves the index it is at, and resumes rendering the next question and answer at stored index once quiz has been answered. If there are no more questions, the completed condition is set to true which provides a result screen, plays a sound, and updates the player score. As stated this is the workaround for accessing data from database in the game, and can work for any type of curricula, on any type of device (like iPhones or Windows Desktop) as long as the file with the format exists, thus expanding the service for more devices wont require changing logic in game engine. A negative, shortsighted side of the solution is that what separates the data within the datafile is the "-" symbol, which in turn means that if teacher uses the symbol in either question or answers, it will break the logic of the system and quiz will be unplayable as data is separated incorrectly.

## Bad Code
### Example One: Collision Preventing Player From Moving Further
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/f0d532d87fb3cec2d87ab90b76b096c28febad6b/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/InteractableSystem.kt#L155-L162  
This is a case where pragmatism came at the cost of quality of game. The collision system with walls works by moving the player a short distance back in the direction they came form when colliding with the wall. There are multiple issues with this. First and foremost is the fact that if movement of the player is fast enough, they can clip through walls, this can partially be solved by placing a cap on movement speed on the joystick movement functionality, since at the moment the player can move faster the further they drag their finger away from the point they first clicked. Regardless of fixing the clipping issue, the fact remains that it looks ugly. When colliding with a wall the collision should ideally make player stand still or potentially slide along it if walking in a diagonal path, the sliding part works partially, but since the collision works by pushing the player back, the collision looks shaky as player collides and moves a few pixel back in rapid succession. Another bad side is the use of a magic number, this case "0.69". The number was used because it was roughly the shortest distance player could be pushed back when colliding, if the push was lower the collision would simply stop working and players would be able to pass through completely freely. Attempts were made at improving the collision system, but as the functionality required to make it more natural was located in multiple entity-systems, the logic was less intuitive than expected, so no alternative solution worked better than this. It essentially became a question of whether or not it was worth spending time on perfecting what was already mostly functional, and we concluded that it was better to move on as the issues were mostly aesthetically, and if a user intentionally decided to brute force their way through a wall there would not be any systematic consequences of the action.

### Example Two: Fetching All User Data On Login
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/f0d532d87fb3cec2d87ab90b76b096c28febad6b/android/src/main/kotlin/ktxGamePrototype01/DBObject.kt#L22-L42  
Due to issues with creating asynchronous functions, this functionality was added to make frequent data access easy, the code is not inherently bad on its own, however it is bad in the context that it is used. Upon login in, every field stored in the users database document is saved locally in the "userObject" variable, the object is accessible from any fragment whether it is to fetch new database data using variables in the object, or to write information in the object to the fragment. There are two noticable issues with this, first and foremost if the information did not get fetched by the time the user clicks the menu and opens a new fragment it can lead to incomplete data being shown, or more likely the system crashing, this issue is especially present when logging out of one account and into a new one. The other issue which persists, is that some of the data stored in the "userObject" variable either remains in the object or in the devices cache when logging out from one user and into another. This issue especially affects the open world game, as even though all local quiz files are deleted and new ones are fetched, the open world game sometimes still decides to show the data which was shown for the previous user logged in even though it shouldn't. So either the variable responsible for fetching all the quizzes for each classrooms are not updated properly or LibGDX has a cache that we didn't figure out how to wipe.  

## Code Refactoring

### Interactable System Refactoring
Before Refactoring:  
https://github.com/TrustworthyBlake/ktxGamePrototype01/blob/b26b6c9c500a6510d5c8d5bc46f010f9b2c53cf2/core/src/main/kotlin/ktxGamePrototype01/entityComponentSystem/system/InteractableSystem.kt#L83-L165

After Refactoring:  


The code

## Professionalism in Programming Reflection.
